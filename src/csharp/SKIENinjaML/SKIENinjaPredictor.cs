/*
 * SKIENinja ML Predictor
 *
 * ONNX-based inference for the Volatility Breakout Strategy.
 * Designed for integration with NinjaTrader 8.
 * C# 5.0 compatible for .NET Framework 4.8 compilation.
 *
 * Author: SKIE_Ninja Development Team
 * Created: 2025-12-05
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML.OnnxRuntime;
using Microsoft.ML.OnnxRuntime.Tensors;
using Newtonsoft.Json;

namespace SKIENinjaML
{
    /// <summary>
    /// Scaler parameters for feature normalization.
    /// Handles both singular (mean/scale) and plural (means/scales) JSON keys.
    /// </summary>
    public class ScalerParams
    {
        public List<string> feature_names { get; set; }

        // Support both naming conventions from different export scripts
        [JsonProperty("mean")]
        public List<double> mean { get; set; }

        [JsonProperty("means")]
        public List<double> means { get; set; }

        [JsonProperty("scale")]
        public List<double> scale { get; set; }

        [JsonProperty("scales")]
        public List<double> scales { get; set; }

        public int n_features { get; set; }

        /// <summary>
        /// Get mean values, handling both naming conventions.
        /// </summary>
        public List<double> GetMeans()
        {
            return mean ?? means ?? new List<double>();
        }

        /// <summary>
        /// Get scale values, handling both naming conventions.
        /// </summary>
        public List<double> GetScales()
        {
            return scale ?? scales ?? new List<double>();
        }
    }

    /// <summary>
    /// Strategy configuration parameters.
    /// </summary>
    public class StrategyConfig
    {
        public double min_vol_expansion_prob { get; set; }
        public double min_sentiment_vol_prob { get; set; }
        public double min_breakout_prob { get; set; }
        public double tp_atr_mult_base { get; set; }
        public double sl_atr_mult_base { get; set; }
        public double tp_adjustment_factor { get; set; }
        public int max_holding_bars { get; set; }
        public int base_contracts { get; set; }
        public int max_contracts { get; set; }
        public double vol_sizing_factor { get; set; }
        public string ensemble_mode { get; set; }

        public StrategyConfig()
        {
            min_vol_expansion_prob = 0.50;
            min_sentiment_vol_prob = 0.55;
            min_breakout_prob = 0.50;
            tp_atr_mult_base = 2.0;
            sl_atr_mult_base = 1.0;
            tp_adjustment_factor = 0.25;
            max_holding_bars = 20;
            base_contracts = 1;
            max_contracts = 3;
            vol_sizing_factor = 1.0;
            ensemble_mode = "agreement";
        }
    }

    /// <summary>
    /// Trading signal generated by the model.
    /// </summary>
    public class TradingSignal
    {
        public bool ShouldTrade { get; set; }
        public int Direction { get; set; }
        public int Contracts { get; set; }
        public double TakeProfitOffset { get; set; }
        public double StopLossOffset { get; set; }
        public double VolExpansionProb { get; set; }
        public double SentimentVolProb { get; set; }
        public double BreakoutProb { get; set; }
        public double PredictedATR { get; set; }
    }

    /// <summary>
    /// Main predictor class for SKIE_Ninja ML models.
    /// </summary>
    public class SKIENinjaPredictor : IDisposable
    {
        private InferenceSession _volModel;
        private InferenceSession _highModel;
        private InferenceSession _lowModel;
        private InferenceSession _atrModel;

        private ScalerParams _scalerParams;
        private StrategyConfig _config;

        private bool _isInitialized = false;
        private string _modelPath;

        /// <summary>
        /// Initialize the predictor with model files.
        /// </summary>
        public void Initialize(string modelPath)
        {
            _modelPath = modelPath;

            // Load scaler params
            string scalerPath = Path.Combine(modelPath, "scaler_params.json");
            if (File.Exists(scalerPath))
            {
                string json = File.ReadAllText(scalerPath);
                _scalerParams = JsonConvert.DeserializeObject<ScalerParams>(json);
            }
            else
            {
                throw new FileNotFoundException(String.Format("Scaler params not found: {0}", scalerPath));
            }

            // Load strategy config
            string configPath = Path.Combine(modelPath, "strategy_config.json");
            if (File.Exists(configPath))
            {
                string json = File.ReadAllText(configPath);
                _config = JsonConvert.DeserializeObject<StrategyConfig>(json);
            }
            else
            {
                _config = new StrategyConfig();
            }

            // Load ONNX models
            SessionOptions sessionOptions = new SessionOptions();
            sessionOptions.GraphOptimizationLevel = GraphOptimizationLevel.ORT_ENABLE_ALL;

            _volModel = new InferenceSession(
                Path.Combine(modelPath, "vol_expansion_model.onnx"), sessionOptions);
            _highModel = new InferenceSession(
                Path.Combine(modelPath, "breakout_high_model.onnx"), sessionOptions);
            _lowModel = new InferenceSession(
                Path.Combine(modelPath, "breakout_low_model.onnx"), sessionOptions);
            _atrModel = new InferenceSession(
                Path.Combine(modelPath, "atr_forecast_model.onnx"), sessionOptions);

            _isInitialized = true;
        }

        /// <summary>
        /// Scale features using stored scaler parameters.
        /// </summary>
        private float[] ScaleFeatures(double[] features)
        {
            List<double> meanValues = _scalerParams.GetMeans();
            List<double> scaleValues = _scalerParams.GetScales();

            float[] scaled = new float[features.Length];
            for (int i = 0; i < features.Length; i++)
            {
                scaled[i] = (float)((features[i] - meanValues[i]) / scaleValues[i]);
            }
            return scaled;
        }

        /// <summary>
        /// Run classifier model and get probability of positive class.
        /// </summary>
        private double RunClassifier(InferenceSession session, float[] features)
        {
            DenseTensor<float> tensor = new DenseTensor<float>(features, new int[] { 1, features.Length });
            List<NamedOnnxValue> inputs = new List<NamedOnnxValue>();
            inputs.Add(NamedOnnxValue.CreateFromTensor("features", tensor));

            using (IDisposableReadOnlyCollection<DisposableNamedOnnxValue> results = session.Run(inputs))
            {
                // LightGBM classifier outputs: label (index 0), probabilities (index 1)
                // Output[1] is seq(map(int64, float)) - sequence of dictionaries
                DisposableNamedOnnxValue probOutput = results.ElementAt(1);
                object value = probOutput.Value;

                if (value == null)
                {
                    throw new InvalidOperationException("ONNX output value is null");
                }

                // The value is a DisposableList of DisposableNamedOnnxValue
                // Each element in the list is a map (dictionary) for one sample
                if (value is System.Collections.IEnumerable enumerable)
                {
                    foreach (object item in enumerable)
                    {
                        // Each item should be a DisposableNamedOnnxValue containing a dictionary
                        if (item is DisposableNamedOnnxValue namedValue)
                        {
                            object innerValue = namedValue.Value;
                            if (innerValue is IDictionary<long, float> dict)
                            {
                                if (dict.ContainsKey(1))
                                {
                                    return dict[1];
                                }
                            }
                        }
                        // Or it might directly be a dictionary
                        else if (item is IDictionary<long, float> directDict)
                        {
                            if (directDict.ContainsKey(1))
                            {
                                return directDict[1];
                            }
                        }
                    }
                }

                // Try direct cast approaches as fallback
                if (value is IList<IDictionary<long, float>> listOfDicts && listOfDicts.Count > 0)
                {
                    if (listOfDicts[0].ContainsKey(1))
                    {
                        return listOfDicts[0][1];
                    }
                }

                // Fallback: return 0.5 (neutral probability)
                return 0.5;
            }
        }

        /// <summary>
        /// Run regressor model and get prediction.
        /// </summary>
        private double RunRegressor(InferenceSession session, float[] features)
        {
            DenseTensor<float> tensor = new DenseTensor<float>(features, new int[] { 1, features.Length });
            List<NamedOnnxValue> inputs = new List<NamedOnnxValue>();
            inputs.Add(NamedOnnxValue.CreateFromTensor("features", tensor));

            using (IDisposableReadOnlyCollection<DisposableNamedOnnxValue> results = session.Run(inputs))
            {
                IEnumerable<float> output = results.First().AsEnumerable<float>();
                return output.First();
            }
        }

        /// <summary>
        /// Generate trading signal from features.
        /// </summary>
        public TradingSignal GenerateSignal(double[] features, double currentATR)
        {
            if (!_isInitialized)
            {
                throw new InvalidOperationException("Predictor not initialized. Call Initialize() first.");
            }

            TradingSignal signal = new TradingSignal();

            // Scale features
            float[] scaledFeatures = ScaleFeatures(features);

            // Get predictions
            double volProb = RunClassifier(_volModel, scaledFeatures);
            double highProb = RunClassifier(_highModel, scaledFeatures);
            double lowProb = RunClassifier(_lowModel, scaledFeatures);
            double predictedATR = RunRegressor(_atrModel, scaledFeatures);

            signal.VolExpansionProb = volProb;
            signal.PredictedATR = predictedATR;

            // 1. Volatility filter
            if (volProb < _config.min_vol_expansion_prob)
            {
                signal.ShouldTrade = false;
                signal.Direction = 0;
                return signal;
            }

            // 2. Direction from breakout probabilities
            bool highSignal = highProb >= _config.min_breakout_prob;
            bool lowSignal = lowProb >= _config.min_breakout_prob;

            if (highSignal && !lowSignal)
            {
                signal.Direction = 1;
                signal.BreakoutProb = highProb;
            }
            else if (lowSignal && !highSignal)
            {
                signal.Direction = -1;
                signal.BreakoutProb = lowProb;
            }
            else if (highSignal && lowSignal)
            {
                if (highProb > lowProb)
                {
                    signal.Direction = 1;
                    signal.BreakoutProb = highProb;
                }
                else
                {
                    signal.Direction = -1;
                    signal.BreakoutProb = lowProb;
                }
            }
            else
            {
                signal.ShouldTrade = false;
                signal.Direction = 0;
                return signal;
            }

            signal.ShouldTrade = true;

            // 3. Position sizing (inverse volatility)
            double volFactor = currentATR / (predictedATR + 1e-10);
            volFactor = Math.Max(0.5, Math.Min(2.0, volFactor));

            signal.Contracts = (int)(_config.base_contracts * volFactor * _config.vol_sizing_factor);
            signal.Contracts = Math.Max(1, Math.Min(signal.Contracts, _config.max_contracts));

            // 4. Dynamic exits based on predicted ATR
            double tpMult = _config.tp_atr_mult_base *
                (1 + _config.tp_adjustment_factor * (signal.BreakoutProb - 0.5));
            double slMult = _config.sl_atr_mult_base;

            signal.TakeProfitOffset = tpMult * predictedATR * signal.Direction;
            signal.StopLossOffset = -slMult * predictedATR * signal.Direction;

            return signal;
        }

        /// <summary>
        /// Get the number of features expected by the model.
        /// </summary>
        public int GetFeatureCount()
        {
            if (_scalerParams != null)
            {
                return _scalerParams.n_features;
            }
            return 0;
        }

        /// <summary>
        /// Get the feature names in order.
        /// </summary>
        public List<string> GetFeatureNames()
        {
            if (_scalerParams != null)
            {
                return _scalerParams.feature_names;
            }
            return new List<string>();
        }

        /// <summary>
        /// Get the strategy configuration.
        /// </summary>
        public StrategyConfig GetConfig()
        {
            return _config;
        }

        /// <summary>
        /// Dispose resources.
        /// </summary>
        public void Dispose()
        {
            if (_volModel != null) _volModel.Dispose();
            if (_highModel != null) _highModel.Dispose();
            if (_lowModel != null) _lowModel.Dispose();
            if (_atrModel != null) _atrModel.Dispose();
        }
    }
}
